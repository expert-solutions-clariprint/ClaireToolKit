xml_escaper <: filter()

xml_escaper!(self:port) : xml_escaper ->
	filter!(xml_escaper(), self)

write_port(self:xml_escaper, buf:char*, len:integer) : integer ->
	(for i in (1 .. len)
			case buf[i]
				({'<'} fwrite("&lt;", self.target),
				{'>'} fwrite("&gt;", self.target),
				{'&'} fwrite("&amp;", self.target),
				any putc(buf[i], self.target)),
		len)

V_SOAP:integer := 2

SOAP_IN:any := unknown
PORT_IN:port := unknown

[claire/load_wcl(arg:{"*.wsdl"}) : void -> 	setenv("WCL_HIDE_MENU=1"), wsdlMain()]

[wsdlMain() : void ->
	//[0] == Query WSDL of service ~A // SERVICE_NAME,
	header("Content-Type: text/xml"),
	wsdl!()]

// resolve soap call any make it
[makeSoapCall() : any ->
	//[-100] == Looking for soap_api with first argument of class ~S // owner(SOAP_IN),
	when m := some(m in soap_api.restrictions|length(m.domain) = 2 & m.domain[1] = owner(SOAP_IN) & m.domain[2] <= SoapOut)
	in let out := new(m.domain[2])
		in (//[-100] == Calling soap_api @ (~S, ~S) // owner(SOAP_IN), owner(out),
			apply(m, list(SOAP_IN, out)),
			out)
	else (//[-100] == Error : no soap_api restriction found with domain ~S  // owner(SOAP_IN),
			error("no soap_api restriction found for ~S", SOAP_IN))]

[soap_message_enter(parser:Sax/sax_parser,ctx:any, s:string, attr:table) : void -> 
	//[V_SOAP] toplevelTagEnter<~A> // s,
	if (right(lower(s), 5) = ":body")
		SOAP_IN := Xmlo/unXml!(PORT_IN,parser)]

[soap_message_enter(parser:Sax/sax_parser, s:string, attr:table) : void -> 
	//[V_SOAP] toplevelTagEnter<~A> // s,
	if (right(lower(s), 5) = ":body")
		SOAP_IN := Xmlo/unXml!(PORT_IN,parser)]

[soap_message_leave(parser:Sax/sax_parser, ctx:any, s:string, cdata:string) : void -> 
	//[V_SOAP] toplevelTagLeave</~A> // s
	]

[soap_message_leave(parser:Sax/sax_parser, s:string, cdata:string) : void -> 
	//[V_SOAP] toplevelTagLeave</~A> // s
	]




// entry point for a soap request (called by Wcl engine)
[Wcl/handle_soap_message(soapin:Wcl/wcl_handler) : any ->
	let res := unknown
	in (if (lower(right(getenv("PATH_INFO"),4)) = "wsdl") wsdlMain()
		else res := handleSoapMessage(soapin),
		res)]


[handleSoapMessage(wcl:Wcl/wcl_handler) : tuple ->
	//[-100] == handle SOAP message from ~S // wcl,
	header("Content-Type: text/xml"),
	let result := unknown,
		debug? := isenv?("WCL_DEBUG"),
		ct := getenv("CONTENT_TYPE"),
		signed&encrypted? := (ct = "application/xml.p7m"),
		error? :=
			(try
				(result :=
					(if signed&encrypted?
						handleSigned&EncryptedSoapMessage(wcl)
					else handleTextSoapMessage(wcl)),
				flush(cout()),
				//[-100] == SOAP Call OK, returned ~S // result,
				not(Wcl/parent_and_children_ok?(wcl)))
			catch any 
				(if debug?
					Wcl/wcl_error(wcl, true),
				true)),
		old := cout()
	in (if (not(error?) & signed&encrypted?)
			(//<sb> when an error occur the returned message isn't encrypted
			header("Content-Type: application/xml.p7m"),
			old := use_as_output(blob!()))
		?><soap:Envelope
				xmlns:claire="http://www.claire-language.com"
				xmlns:Xmlo="http://www.claire-language.com/Xmlo"
				xmlns:Soap="http://www.claire-language.com/Soap"
				xmlns:soap="http://schemas.xmlsoap.org/soap/envelop"><?
		?><soap:Body><?
			(if error?
				(//[-100] == SOAP server error, attach fault string ~S  // exception!(),
				?><soap:Fault><?
					(if debug?
						( ?><faultreport></faultreport><? )
					else
						(
						?><faultstring><?
							princ(url_encode((print_in_string(),
										print(exception!()), end_of_string())))
						?></faultstring><? ))
				?></soap:Fault><? )
			else
				Xmlo/xml!(result, cout())) //<sb> no error, send back the response
		?></soap:Body><?
		?></soap:Envelope><?
		if (not(error?) & signed&encrypted?)
			sign&encryptResponse(use_as_output(old)),
		if (error? & debug?)
			(//[-100] == SOAP server error, attach a fault report,
			//<sb> when in debug, we include a fault report
			// that can be displayed on the client page.
			// the client page should be generated by Wcl/Soap
			// engine (see response_parse.cl).
			Wcl/terminate_wcl_response(wcl),
			Wcl/dump_report(wcl)),
		tuple(SOAP_IN, result))]


[handleTextSoapMessage(from:Wcl/wcl_handler) : SoapOut ->
	//[-100] == parse text SOAP message ,
	PORT_IN := from,
	Sax/sax(from, soap_message_enter, soap_message_leave),
	//[-100] == SOAP text/xml parsed  end?=~S // eof?(PORT_IN),
	bleedInput(PORT_IN),
	makeSoapCall() as SoapOut]

[bleedInput(self:port) : void ->
	while not(eof?(self))
		let r := freadline(self) in //[1] bleedInput(~S) : ~S // self,r
		]


on_fill_security_context :: property(open = 3)
on_get_possible_recipients :: property(open = 3)

[handleSigned&EncryptedSoapMessage(from:Wcl/wcl_handler) : SoapOut ->
	//[-100] == parse encrypted SOAP message ,
	let ctx := security_context(),
		sa := replace(getenv("HTTP_SOAPACTION"), "\"",""),
		p7 := Openssl/d2i_PKCS7(fread(from)),
		recipients := Openssl/get_recipients(p7, on_get_possible_recipients(sa))
	in (if not(recipients)
			error("handleSigned&EncryptedSoapMessage: unable to get recipient certificate"),
		ctx.recipient := recipients[1],
		//[-100] == Recipient is ~S // ctx.recipient,
		//[-100] == Fill security context attempt (~S, ~S) // sa, ctx,
		on_fill_security_context(sa, ctx), //<sb> ctx.recipient_pkey/trusted should be filled in !
		//[-100] == Security context filled,
		let dec_p7 := Openssl/d2i_PKCS7(string!(Openssl/decrypt(p7, ctx.recipient, ctx.recipient_pkey))),
			b := blob!()
		in (if not(Openssl/verify(dec_p7, ctx.trusted, ctx.untrusted, b)) //<sb> extract xml from PKCS7 signed content
				error("Verification failed : ~A", dec_p7.Openssl/verify_message),
			PORT_IN := b,
			Sax/sax(b, soap_message_enter, soap_message_leave),
			ctx.sender := Openssl/get_signers(dec_p7)[1],
			(SOAP_IN as SoapIn).secure_context := ctx,
			//[-100] == SOAP application/xml.p7m parsed ,
			makeSoapCall() as SoapOut))]


[sign&encryptResponse(p:port) : void ->
	//[-100] == sign&encryptResponse,
	let ctx := SOAP_IN.secure_context,
		p7 := Openssl/sign&encrypt(ctx.recipient, ctx.recipient_pkey, nil, list(ctx.sender), p)
	in fwrite(Openssl/i2d(p7), cout())]
